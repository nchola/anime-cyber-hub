// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './database.types';
import { getUserBookmarks, saveBookmark } from '@/lib/supabase';
import { SupabaseBookmark } from '@/types/bookmark';

const SUPABASE_URL = "https://wufknidkprsagfpejrsu.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Ind1ZmtuaWRrcHJzYWdmcGVqcnN1Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM1NjYyNTQsImV4cCI6MjA1OTE0MjI1NH0.uq5hxpX5z9d9jk35Y8uNKpemJlRay7h0-vI3Bn12VPo";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

export async function syncLocalBookmarksWithServer(userId: string) {
  try {
    // Get local bookmarks
    const localBookmarks = JSON.parse(localStorage.getItem('bookmarks') || '[]');
    const localMangaBookmarks = JSON.parse(localStorage.getItem('bookmarkedManga') || '[]');
    
    // Get server bookmarks first
    const { data: serverBookmarks, error } = await getUserBookmarks(userId);
    
    if (error) throw error;
    
    // Create maps for fast lookup
    const serverBookmarkMap = new Map();
    if (serverBookmarks) {
      for (const bookmark of serverBookmarks) {
        serverBookmarkMap.set(`${bookmark.item_type}-${bookmark.item_id}`, bookmark);
      }
    }
    
    // Batch save operations for local bookmarks that aren't on server
    const savePromises = [];
    
    // Process anime bookmarks not already on server
    for (const bookmark of localBookmarks) {
      const key = `anime-${bookmark.id}`;
      if (!serverBookmarkMap.has(key)) {
        savePromises.push(saveBookmark(userId, bookmark.id, 'anime', bookmark));
      }
    }
    
    // Process manga bookmarks not already on server
    for (const bookmark of localMangaBookmarks) {
      const key = `manga-${bookmark.id}`;
      if (!serverBookmarkMap.has(key)) {
        savePromises.push(saveBookmark(userId, bookmark.id, 'manga', bookmark));
      }
    }
    
    // Wait for all save operations to complete
    await Promise.all(savePromises);
    
    // Refresh server bookmarks after saving
    const { data: updatedServerBookmarks, error: refreshError } = await getUserBookmarks(userId);
    
    if (refreshError) throw refreshError;
    
    // Update local storage with server data
    if (updatedServerBookmarks) {
      // Type assertion to handle the data properly
      const bookmarks = updatedServerBookmarks as SupabaseBookmark[];
      
      const animeBookmarks = bookmarks
        .filter(b => b.item_type === 'anime')
        .map(b => b.item_data);
        
      const mangaBookmarks = bookmarks
        .filter(b => b.item_type === 'manga')
        .map(b => b.item_data);
      
      localStorage.setItem('bookmarks', JSON.stringify(animeBookmarks));
      localStorage.setItem('bookmarkedManga', JSON.stringify(mangaBookmarks));
    }
    
    return { data: updatedServerBookmarks, error: null };
  } catch (error) {
    console.error('Error syncing bookmarks:', error);
    return { error };
  }
}